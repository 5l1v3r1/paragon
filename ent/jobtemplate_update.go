// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"

	"github.com/facebookincubator/ent/dialect/sql"
	"github.com/kcarretto/paragon/ent/job"
	"github.com/kcarretto/paragon/ent/jobtemplate"
	"github.com/kcarretto/paragon/ent/predicate"
)

// JobTemplateUpdate is the builder for updating JobTemplate entities.
type JobTemplateUpdate struct {
	config
	Name        *string
	Content     *string
	jobs        map[int]struct{}
	tags        map[int]struct{}
	removedJobs map[int]struct{}
	removedTags map[int]struct{}
	predicates  []predicate.JobTemplate
}

// Where adds a new predicate for the builder.
func (jtu *JobTemplateUpdate) Where(ps ...predicate.JobTemplate) *JobTemplateUpdate {
	jtu.predicates = append(jtu.predicates, ps...)
	return jtu
}

// SetName sets the Name field.
func (jtu *JobTemplateUpdate) SetName(s string) *JobTemplateUpdate {
	jtu.Name = &s
	return jtu
}

// SetContent sets the Content field.
func (jtu *JobTemplateUpdate) SetContent(s string) *JobTemplateUpdate {
	jtu.Content = &s
	return jtu
}

// AddJobIDs adds the jobs edge to Job by ids.
func (jtu *JobTemplateUpdate) AddJobIDs(ids ...int) *JobTemplateUpdate {
	if jtu.jobs == nil {
		jtu.jobs = make(map[int]struct{})
	}
	for i := range ids {
		jtu.jobs[ids[i]] = struct{}{}
	}
	return jtu
}

// AddJobs adds the jobs edges to Job.
func (jtu *JobTemplateUpdate) AddJobs(j ...*Job) *JobTemplateUpdate {
	ids := make([]int, len(j))
	for i := range j {
		ids[i] = j[i].ID
	}
	return jtu.AddJobIDs(ids...)
}

// AddTagIDs adds the tags edge to Tag by ids.
func (jtu *JobTemplateUpdate) AddTagIDs(ids ...int) *JobTemplateUpdate {
	if jtu.tags == nil {
		jtu.tags = make(map[int]struct{})
	}
	for i := range ids {
		jtu.tags[ids[i]] = struct{}{}
	}
	return jtu
}

// AddTags adds the tags edges to Tag.
func (jtu *JobTemplateUpdate) AddTags(t ...*Tag) *JobTemplateUpdate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return jtu.AddTagIDs(ids...)
}

// RemoveJobIDs removes the jobs edge to Job by ids.
func (jtu *JobTemplateUpdate) RemoveJobIDs(ids ...int) *JobTemplateUpdate {
	if jtu.removedJobs == nil {
		jtu.removedJobs = make(map[int]struct{})
	}
	for i := range ids {
		jtu.removedJobs[ids[i]] = struct{}{}
	}
	return jtu
}

// RemoveJobs removes jobs edges to Job.
func (jtu *JobTemplateUpdate) RemoveJobs(j ...*Job) *JobTemplateUpdate {
	ids := make([]int, len(j))
	for i := range j {
		ids[i] = j[i].ID
	}
	return jtu.RemoveJobIDs(ids...)
}

// RemoveTagIDs removes the tags edge to Tag by ids.
func (jtu *JobTemplateUpdate) RemoveTagIDs(ids ...int) *JobTemplateUpdate {
	if jtu.removedTags == nil {
		jtu.removedTags = make(map[int]struct{})
	}
	for i := range ids {
		jtu.removedTags[ids[i]] = struct{}{}
	}
	return jtu
}

// RemoveTags removes tags edges to Tag.
func (jtu *JobTemplateUpdate) RemoveTags(t ...*Tag) *JobTemplateUpdate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return jtu.RemoveTagIDs(ids...)
}

// Save executes the query and returns the number of rows/vertices matched by this operation.
func (jtu *JobTemplateUpdate) Save(ctx context.Context) (int, error) {
	if jtu.Name != nil {
		if err := jobtemplate.NameValidator(*jtu.Name); err != nil {
			return 0, fmt.Errorf("ent: validator failed for field \"Name\": %v", err)
		}
	}
	if jtu.Content != nil {
		if err := jobtemplate.ContentValidator(*jtu.Content); err != nil {
			return 0, fmt.Errorf("ent: validator failed for field \"Content\": %v", err)
		}
	}
	return jtu.sqlSave(ctx)
}

// SaveX is like Save, but panics if an error occurs.
func (jtu *JobTemplateUpdate) SaveX(ctx context.Context) int {
	affected, err := jtu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (jtu *JobTemplateUpdate) Exec(ctx context.Context) error {
	_, err := jtu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (jtu *JobTemplateUpdate) ExecX(ctx context.Context) {
	if err := jtu.Exec(ctx); err != nil {
		panic(err)
	}
}

func (jtu *JobTemplateUpdate) sqlSave(ctx context.Context) (n int, err error) {
	selector := sql.Select(jobtemplate.FieldID).From(sql.Table(jobtemplate.Table))
	for _, p := range jtu.predicates {
		p(selector)
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err = jtu.driver.Query(ctx, query, args, rows); err != nil {
		return 0, err
	}
	defer rows.Close()
	var ids []int
	for rows.Next() {
		var id int
		if err := rows.Scan(&id); err != nil {
			return 0, fmt.Errorf("ent: failed reading id: %v", err)
		}
		ids = append(ids, id)
	}
	if len(ids) == 0 {
		return 0, nil
	}

	tx, err := jtu.driver.Tx(ctx)
	if err != nil {
		return 0, err
	}
	var (
		res     sql.Result
		builder = sql.Update(jobtemplate.Table).Where(sql.InInts(jobtemplate.FieldID, ids...))
	)
	if value := jtu.Name; value != nil {
		builder.Set(jobtemplate.FieldName, *value)
	}
	if value := jtu.Content; value != nil {
		builder.Set(jobtemplate.FieldContent, *value)
	}
	if !builder.Empty() {
		query, args := builder.Query()
		if err := tx.Exec(ctx, query, args, &res); err != nil {
			return 0, rollback(tx, err)
		}
	}
	if len(jtu.removedJobs) > 0 {
		eids := make([]int, len(jtu.removedJobs))
		for eid := range jtu.removedJobs {
			eids = append(eids, eid)
		}
		query, args := sql.Update(jobtemplate.JobsTable).
			SetNull(jobtemplate.JobsColumn).
			Where(sql.InInts(jobtemplate.JobsColumn, ids...)).
			Where(sql.InInts(job.FieldID, eids...)).
			Query()
		if err := tx.Exec(ctx, query, args, &res); err != nil {
			return 0, rollback(tx, err)
		}
	}
	if len(jtu.jobs) > 0 {
		for _, id := range ids {
			p := sql.P()
			for eid := range jtu.jobs {
				p.Or().EQ(job.FieldID, eid)
			}
			query, args := sql.Update(jobtemplate.JobsTable).
				Set(jobtemplate.JobsColumn, id).
				Where(sql.And(p, sql.IsNull(jobtemplate.JobsColumn))).
				Query()
			if err := tx.Exec(ctx, query, args, &res); err != nil {
				return 0, rollback(tx, err)
			}
			affected, err := res.RowsAffected()
			if err != nil {
				return 0, rollback(tx, err)
			}
			if int(affected) < len(jtu.jobs) {
				return 0, rollback(tx, &ErrConstraintFailed{msg: fmt.Sprintf("one of \"jobs\" %v already connected to a different \"JobTemplate\"", keys(jtu.jobs))})
			}
		}
	}
	if len(jtu.removedTags) > 0 {
		eids := make([]int, len(jtu.removedTags))
		for eid := range jtu.removedTags {
			eids = append(eids, eid)
		}
		query, args := sql.Delete(jobtemplate.TagsTable).
			Where(sql.InInts(jobtemplate.TagsPrimaryKey[0], ids...)).
			Where(sql.InInts(jobtemplate.TagsPrimaryKey[1], eids...)).
			Query()
		if err := tx.Exec(ctx, query, args, &res); err != nil {
			return 0, rollback(tx, err)
		}
	}
	if len(jtu.tags) > 0 {
		values := make([][]int, 0, len(ids))
		for _, id := range ids {
			for eid := range jtu.tags {
				values = append(values, []int{id, eid})
			}
		}
		builder := sql.Insert(jobtemplate.TagsTable).
			Columns(jobtemplate.TagsPrimaryKey[0], jobtemplate.TagsPrimaryKey[1])
		for _, v := range values {
			builder.Values(v[0], v[1])
		}
		query, args := builder.Query()
		if err := tx.Exec(ctx, query, args, &res); err != nil {
			return 0, rollback(tx, err)
		}
	}
	if err = tx.Commit(); err != nil {
		return 0, err
	}
	return len(ids), nil
}

// JobTemplateUpdateOne is the builder for updating a single JobTemplate entity.
type JobTemplateUpdateOne struct {
	config
	id          int
	Name        *string
	Content     *string
	jobs        map[int]struct{}
	tags        map[int]struct{}
	removedJobs map[int]struct{}
	removedTags map[int]struct{}
}

// SetName sets the Name field.
func (jtuo *JobTemplateUpdateOne) SetName(s string) *JobTemplateUpdateOne {
	jtuo.Name = &s
	return jtuo
}

// SetContent sets the Content field.
func (jtuo *JobTemplateUpdateOne) SetContent(s string) *JobTemplateUpdateOne {
	jtuo.Content = &s
	return jtuo
}

// AddJobIDs adds the jobs edge to Job by ids.
func (jtuo *JobTemplateUpdateOne) AddJobIDs(ids ...int) *JobTemplateUpdateOne {
	if jtuo.jobs == nil {
		jtuo.jobs = make(map[int]struct{})
	}
	for i := range ids {
		jtuo.jobs[ids[i]] = struct{}{}
	}
	return jtuo
}

// AddJobs adds the jobs edges to Job.
func (jtuo *JobTemplateUpdateOne) AddJobs(j ...*Job) *JobTemplateUpdateOne {
	ids := make([]int, len(j))
	for i := range j {
		ids[i] = j[i].ID
	}
	return jtuo.AddJobIDs(ids...)
}

// AddTagIDs adds the tags edge to Tag by ids.
func (jtuo *JobTemplateUpdateOne) AddTagIDs(ids ...int) *JobTemplateUpdateOne {
	if jtuo.tags == nil {
		jtuo.tags = make(map[int]struct{})
	}
	for i := range ids {
		jtuo.tags[ids[i]] = struct{}{}
	}
	return jtuo
}

// AddTags adds the tags edges to Tag.
func (jtuo *JobTemplateUpdateOne) AddTags(t ...*Tag) *JobTemplateUpdateOne {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return jtuo.AddTagIDs(ids...)
}

// RemoveJobIDs removes the jobs edge to Job by ids.
func (jtuo *JobTemplateUpdateOne) RemoveJobIDs(ids ...int) *JobTemplateUpdateOne {
	if jtuo.removedJobs == nil {
		jtuo.removedJobs = make(map[int]struct{})
	}
	for i := range ids {
		jtuo.removedJobs[ids[i]] = struct{}{}
	}
	return jtuo
}

// RemoveJobs removes jobs edges to Job.
func (jtuo *JobTemplateUpdateOne) RemoveJobs(j ...*Job) *JobTemplateUpdateOne {
	ids := make([]int, len(j))
	for i := range j {
		ids[i] = j[i].ID
	}
	return jtuo.RemoveJobIDs(ids...)
}

// RemoveTagIDs removes the tags edge to Tag by ids.
func (jtuo *JobTemplateUpdateOne) RemoveTagIDs(ids ...int) *JobTemplateUpdateOne {
	if jtuo.removedTags == nil {
		jtuo.removedTags = make(map[int]struct{})
	}
	for i := range ids {
		jtuo.removedTags[ids[i]] = struct{}{}
	}
	return jtuo
}

// RemoveTags removes tags edges to Tag.
func (jtuo *JobTemplateUpdateOne) RemoveTags(t ...*Tag) *JobTemplateUpdateOne {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return jtuo.RemoveTagIDs(ids...)
}

// Save executes the query and returns the updated entity.
func (jtuo *JobTemplateUpdateOne) Save(ctx context.Context) (*JobTemplate, error) {
	if jtuo.Name != nil {
		if err := jobtemplate.NameValidator(*jtuo.Name); err != nil {
			return nil, fmt.Errorf("ent: validator failed for field \"Name\": %v", err)
		}
	}
	if jtuo.Content != nil {
		if err := jobtemplate.ContentValidator(*jtuo.Content); err != nil {
			return nil, fmt.Errorf("ent: validator failed for field \"Content\": %v", err)
		}
	}
	return jtuo.sqlSave(ctx)
}

// SaveX is like Save, but panics if an error occurs.
func (jtuo *JobTemplateUpdateOne) SaveX(ctx context.Context) *JobTemplate {
	jt, err := jtuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return jt
}

// Exec executes the query on the entity.
func (jtuo *JobTemplateUpdateOne) Exec(ctx context.Context) error {
	_, err := jtuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (jtuo *JobTemplateUpdateOne) ExecX(ctx context.Context) {
	if err := jtuo.Exec(ctx); err != nil {
		panic(err)
	}
}

func (jtuo *JobTemplateUpdateOne) sqlSave(ctx context.Context) (jt *JobTemplate, err error) {
	selector := sql.Select(jobtemplate.Columns...).From(sql.Table(jobtemplate.Table))
	jobtemplate.ID(jtuo.id)(selector)
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err = jtuo.driver.Query(ctx, query, args, rows); err != nil {
		return nil, err
	}
	defer rows.Close()
	var ids []int
	for rows.Next() {
		var id int
		jt = &JobTemplate{config: jtuo.config}
		if err := jt.FromRows(rows); err != nil {
			return nil, fmt.Errorf("ent: failed scanning row into JobTemplate: %v", err)
		}
		id = jt.ID
		ids = append(ids, id)
	}
	switch n := len(ids); {
	case n == 0:
		return nil, &ErrNotFound{fmt.Sprintf("JobTemplate with id: %v", jtuo.id)}
	case n > 1:
		return nil, fmt.Errorf("ent: more than one JobTemplate with the same id: %v", jtuo.id)
	}

	tx, err := jtuo.driver.Tx(ctx)
	if err != nil {
		return nil, err
	}
	var (
		res     sql.Result
		builder = sql.Update(jobtemplate.Table).Where(sql.InInts(jobtemplate.FieldID, ids...))
	)
	if value := jtuo.Name; value != nil {
		builder.Set(jobtemplate.FieldName, *value)
		jt.Name = *value
	}
	if value := jtuo.Content; value != nil {
		builder.Set(jobtemplate.FieldContent, *value)
		jt.Content = *value
	}
	if !builder.Empty() {
		query, args := builder.Query()
		if err := tx.Exec(ctx, query, args, &res); err != nil {
			return nil, rollback(tx, err)
		}
	}
	if len(jtuo.removedJobs) > 0 {
		eids := make([]int, len(jtuo.removedJobs))
		for eid := range jtuo.removedJobs {
			eids = append(eids, eid)
		}
		query, args := sql.Update(jobtemplate.JobsTable).
			SetNull(jobtemplate.JobsColumn).
			Where(sql.InInts(jobtemplate.JobsColumn, ids...)).
			Where(sql.InInts(job.FieldID, eids...)).
			Query()
		if err := tx.Exec(ctx, query, args, &res); err != nil {
			return nil, rollback(tx, err)
		}
	}
	if len(jtuo.jobs) > 0 {
		for _, id := range ids {
			p := sql.P()
			for eid := range jtuo.jobs {
				p.Or().EQ(job.FieldID, eid)
			}
			query, args := sql.Update(jobtemplate.JobsTable).
				Set(jobtemplate.JobsColumn, id).
				Where(sql.And(p, sql.IsNull(jobtemplate.JobsColumn))).
				Query()
			if err := tx.Exec(ctx, query, args, &res); err != nil {
				return nil, rollback(tx, err)
			}
			affected, err := res.RowsAffected()
			if err != nil {
				return nil, rollback(tx, err)
			}
			if int(affected) < len(jtuo.jobs) {
				return nil, rollback(tx, &ErrConstraintFailed{msg: fmt.Sprintf("one of \"jobs\" %v already connected to a different \"JobTemplate\"", keys(jtuo.jobs))})
			}
		}
	}
	if len(jtuo.removedTags) > 0 {
		eids := make([]int, len(jtuo.removedTags))
		for eid := range jtuo.removedTags {
			eids = append(eids, eid)
		}
		query, args := sql.Delete(jobtemplate.TagsTable).
			Where(sql.InInts(jobtemplate.TagsPrimaryKey[0], ids...)).
			Where(sql.InInts(jobtemplate.TagsPrimaryKey[1], eids...)).
			Query()
		if err := tx.Exec(ctx, query, args, &res); err != nil {
			return nil, rollback(tx, err)
		}
	}
	if len(jtuo.tags) > 0 {
		values := make([][]int, 0, len(ids))
		for _, id := range ids {
			for eid := range jtuo.tags {
				values = append(values, []int{id, eid})
			}
		}
		builder := sql.Insert(jobtemplate.TagsTable).
			Columns(jobtemplate.TagsPrimaryKey[0], jobtemplate.TagsPrimaryKey[1])
		for _, v := range values {
			builder.Values(v[0], v[1])
		}
		query, args := builder.Query()
		if err := tx.Exec(ctx, query, args, &res); err != nil {
			return nil, rollback(tx, err)
		}
	}
	if err = tx.Commit(); err != nil {
		return nil, err
	}
	return jt, nil
}
