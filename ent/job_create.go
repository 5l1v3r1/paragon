// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/facebookincubator/ent/dialect/sql"
	"github.com/kcarretto/paragon/ent/job"
	"github.com/kcarretto/paragon/ent/task"
)

// JobCreate is the builder for creating a Job entity.
type JobCreate struct {
	config
	Name         *string
	CreationTime *time.Time
	Content      *string
	tasks        map[int]struct{}
	tags         map[int]struct{}
	prev         map[int]struct{}
	next         map[int]struct{}
}

// SetName sets the Name field.
func (jc *JobCreate) SetName(s string) *JobCreate {
	jc.Name = &s
	return jc
}

// SetCreationTime sets the CreationTime field.
func (jc *JobCreate) SetCreationTime(t time.Time) *JobCreate {
	jc.CreationTime = &t
	return jc
}

// SetNillableCreationTime sets the CreationTime field if the given value is not nil.
func (jc *JobCreate) SetNillableCreationTime(t *time.Time) *JobCreate {
	if t != nil {
		jc.SetCreationTime(*t)
	}
	return jc
}

// SetContent sets the Content field.
func (jc *JobCreate) SetContent(s string) *JobCreate {
	jc.Content = &s
	return jc
}

// AddTaskIDs adds the tasks edge to Task by ids.
func (jc *JobCreate) AddTaskIDs(ids ...int) *JobCreate {
	if jc.tasks == nil {
		jc.tasks = make(map[int]struct{})
	}
	for i := range ids {
		jc.tasks[ids[i]] = struct{}{}
	}
	return jc
}

// AddTasks adds the tasks edges to Task.
func (jc *JobCreate) AddTasks(t ...*Task) *JobCreate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return jc.AddTaskIDs(ids...)
}

// AddTagIDs adds the tags edge to Tag by ids.
func (jc *JobCreate) AddTagIDs(ids ...int) *JobCreate {
	if jc.tags == nil {
		jc.tags = make(map[int]struct{})
	}
	for i := range ids {
		jc.tags[ids[i]] = struct{}{}
	}
	return jc
}

// AddTags adds the tags edges to Tag.
func (jc *JobCreate) AddTags(t ...*Tag) *JobCreate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return jc.AddTagIDs(ids...)
}

// SetPrevID sets the prev edge to Job by id.
func (jc *JobCreate) SetPrevID(id int) *JobCreate {
	if jc.prev == nil {
		jc.prev = make(map[int]struct{})
	}
	jc.prev[id] = struct{}{}
	return jc
}

// SetNillablePrevID sets the prev edge to Job by id if the given value is not nil.
func (jc *JobCreate) SetNillablePrevID(id *int) *JobCreate {
	if id != nil {
		jc = jc.SetPrevID(*id)
	}
	return jc
}

// SetPrev sets the prev edge to Job.
func (jc *JobCreate) SetPrev(j *Job) *JobCreate {
	return jc.SetPrevID(j.ID)
}

// SetNextID sets the next edge to Job by id.
func (jc *JobCreate) SetNextID(id int) *JobCreate {
	if jc.next == nil {
		jc.next = make(map[int]struct{})
	}
	jc.next[id] = struct{}{}
	return jc
}

// SetNillableNextID sets the next edge to Job by id if the given value is not nil.
func (jc *JobCreate) SetNillableNextID(id *int) *JobCreate {
	if id != nil {
		jc = jc.SetNextID(*id)
	}
	return jc
}

// SetNext sets the next edge to Job.
func (jc *JobCreate) SetNext(j *Job) *JobCreate {
	return jc.SetNextID(j.ID)
}

// Save creates the Job in the database.
func (jc *JobCreate) Save(ctx context.Context) (*Job, error) {
	if jc.Name == nil {
		return nil, errors.New("ent: missing required field \"Name\"")
	}
	if err := job.NameValidator(*jc.Name); err != nil {
		return nil, fmt.Errorf("ent: validator failed for field \"Name\": %v", err)
	}
	if jc.CreationTime == nil {
		v := job.DefaultCreationTime()
		jc.CreationTime = &v
	}
	if jc.Content == nil {
		return nil, errors.New("ent: missing required field \"Content\"")
	}
	if err := job.ContentValidator(*jc.Content); err != nil {
		return nil, fmt.Errorf("ent: validator failed for field \"Content\": %v", err)
	}
	if len(jc.prev) > 1 {
		return nil, errors.New("ent: multiple assignments on a unique edge \"prev\"")
	}
	if len(jc.next) > 1 {
		return nil, errors.New("ent: multiple assignments on a unique edge \"next\"")
	}
	return jc.sqlSave(ctx)
}

// SaveX calls Save and panics if Save returns an error.
func (jc *JobCreate) SaveX(ctx context.Context) *Job {
	v, err := jc.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

func (jc *JobCreate) sqlSave(ctx context.Context) (*Job, error) {
	var (
		res sql.Result
		j   = &Job{config: jc.config}
	)
	tx, err := jc.driver.Tx(ctx)
	if err != nil {
		return nil, err
	}
	builder := sql.Dialect(jc.driver.Dialect()).
		Insert(job.Table).
		Default()
	if value := jc.Name; value != nil {
		builder.Set(job.FieldName, *value)
		j.Name = *value
	}
	if value := jc.CreationTime; value != nil {
		builder.Set(job.FieldCreationTime, *value)
		j.CreationTime = *value
	}
	if value := jc.Content; value != nil {
		builder.Set(job.FieldContent, *value)
		j.Content = *value
	}
	query, args := builder.Query()
	if err := tx.Exec(ctx, query, args, &res); err != nil {
		return nil, rollback(tx, err)
	}
	id, err := res.LastInsertId()
	if err != nil {
		return nil, rollback(tx, err)
	}
	j.ID = int(id)
	if len(jc.tasks) > 0 {
		p := sql.P()
		for eid := range jc.tasks {
			p.Or().EQ(task.FieldID, eid)
		}
		query, args := sql.Update(job.TasksTable).
			Set(job.TasksColumn, id).
			Where(sql.And(p, sql.IsNull(job.TasksColumn))).
			Query()
		if err := tx.Exec(ctx, query, args, &res); err != nil {
			return nil, rollback(tx, err)
		}
		affected, err := res.RowsAffected()
		if err != nil {
			return nil, rollback(tx, err)
		}
		if int(affected) < len(jc.tasks) {
			return nil, rollback(tx, &ErrConstraintFailed{msg: fmt.Sprintf("one of \"tasks\" %v already connected to a different \"Job\"", keys(jc.tasks))})
		}
	}
	if len(jc.tags) > 0 {
		for eid := range jc.tags {

			query, args := sql.Insert(job.TagsTable).
				Columns(job.TagsPrimaryKey[0], job.TagsPrimaryKey[1]).
				Values(id, eid).
				Query()
			if err := tx.Exec(ctx, query, args, &res); err != nil {
				return nil, rollback(tx, err)
			}
		}
	}
	if len(jc.prev) > 0 {
		eid := keys(jc.prev)[0]
		query, args := sql.Update(job.PrevTable).
			Set(job.PrevColumn, eid).
			Where(sql.EQ(job.FieldID, id).And().IsNull(job.PrevColumn)).
			Query()
		if err := tx.Exec(ctx, query, args, &res); err != nil {
			return nil, rollback(tx, err)
		}
		affected, err := res.RowsAffected()
		if err != nil {
			return nil, rollback(tx, err)
		}
		if int(affected) < len(jc.prev) {
			return nil, rollback(tx, &ErrConstraintFailed{msg: fmt.Sprintf("one of \"prev\" %v already connected to a different \"Job\"", keys(jc.prev))})
		}
	}
	if len(jc.next) > 0 {
		eid := keys(jc.next)[0]
		query, args := sql.Update(job.NextTable).
			Set(job.NextColumn, id).
			Where(sql.EQ(job.FieldID, eid).And().IsNull(job.NextColumn)).
			Query()
		if err := tx.Exec(ctx, query, args, &res); err != nil {
			return nil, rollback(tx, err)
		}
		affected, err := res.RowsAffected()
		if err != nil {
			return nil, rollback(tx, err)
		}
		if int(affected) < len(jc.next) {
			return nil, rollback(tx, &ErrConstraintFailed{msg: fmt.Sprintf("one of \"next\" %v already connected to a different \"Job\"", keys(jc.next))})
		}
	}
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	return j, nil
}
